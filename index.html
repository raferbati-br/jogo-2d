<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Tetris na unha</title>
    <style>
      body { margin: 0; background: #000; }
      canvas { display: block; background: #111; }
    </style>
  </head>
  <body>
    <!-- IMPORTANTE: o id tem que ser exatamente "game" -->
    <canvas id="game"></canvas>

    <!-- IMPORTANTE: script depois do canvas -->
    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      // --- GRID ---
      const COLS = 10;
      const ROWS = 20;
      const CELL = 30;

      canvas.width = COLS * CELL;
      canvas.height = ROWS * CELL;

      // --- BOARD ---
      const board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));

      // --- INPUT (edge) ---
      const down = new Set();
      const pressed = new Set();

      window.addEventListener("keydown", (e) => {
        if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
        if (!down.has(e.key)) pressed.add(e.key);
        down.add(e.key);
      });

      window.addEventListener("keyup", (e) => {
        down.delete(e.key);
      });

      // --- PIECE I (4x4) ---
      const I_SHAPE = [
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0],
      ];
      const T_SHAPE = [
        [0,0,0,0],
        [0,1,0,0],
        [1,1,1,0],
        [0,0,0,0],
      ];
      const O_SHAPE = [
        [0,0,0,0],
        [0,1,1,0],
        [0,1,1,0],
        [0,0,0,0],
      ];
      const S_SHAPE = [
        [0,0,0,0],
        [0,1,1,0],
        [1,1,0,0],
        [0,0,0,0],
      ];
      const Z_SHAPE = [
        [0,0,0,0],
        [1,1,0,0],
        [0,1,1,0],
        [0,0,0,0],
      ];
      const L_SHAPE = [
        [0,0,0,0],
        [0,0,1,0],
        [1,1,1,0],
        [0,0,0,0],
      ];
      const J_SHAPE = [
        [0,0,0,0],
        [1,0,0,0],
        [1,1,1,0],
        [0,0,0,0],
      ];

      function clone4(shape) { return shape.map(row => row.slice()); }

      const COLORS = {
        I: "#4dd9ff",
        T: "#a277ff",
        O: "#ffd85a",
        S: "#59d27c",
        Z: "#ff6b6b",
        L: "#ffb45a",
        J: "#5a7bff",
      };

      const active = { c: 3, r: 0, shape: clone4(I_SHAPE), id: "I" };

      function collides(shape, baseC, baseR) {
        for (let r = 0; r < 4; r++) for (let c = 0; c < 4; c++) {
          if (!shape[r][c]) continue;
          const gc = baseC + c, gr = baseR + r;
          if (gc < 0 || gc >= COLS || gr < 0 || gr >= ROWS) return true;
          if (board[gr][gc]) return true;
        }
        return false;
      }

      function tryMoveActive(dc, dr) {
        const nc = active.c + dc, nr = active.r + dr;
        if (collides(active.shape, nc, nr)) return false;
        active.c = nc; active.r = nr; return true;
      }

      function rotateCW(shape) {
        const out = Array.from({ length: 4 }, () => Array(4).fill(0));
        for (let r = 0; r < 4; r++) for (let c = 0; c < 4; c++) out[c][3 - r] = shape[r][c];
        return out;
      }

      function tryRotateCW() {
        const rotated = rotateCW(active.shape);
        if (!collides(rotated, active.c, active.r)) { active.shape = rotated; return true; }
        if (!collides(rotated, active.c - 1, active.r)) { active.c -= 1; active.shape = rotated; return true; }
        if (!collides(rotated, active.c + 1, active.r)) { active.c += 1; active.shape = rotated; return true; }
        return false;
      }

      function lockActiveToBoard() {
        for (let r = 0; r < 4; r++) for (let c = 0; c < 4; c++) {
          if (!active.shape[r][c]) continue;
          const gr = active.r + r, gc = active.c + c;
          if (gr >= 0 && gr < ROWS && gc >= 0 && gc < COLS) board[gr][gc] = active.id;
        }
      }

      function clearLines() {
        let cleared = 0;
        for (let r = ROWS - 1; r >= 0; r--) {
          let full = true;
          for (let c = 0; c < COLS; c++) if (!board[r][c]) { full = false; break; }
          if (full) { board.splice(r, 1); board.unshift(Array(COLS).fill(0)); r++; cleared++; }
        }
        return cleared;
      }

      function spawnRandom() {
        const bag = [
          ["I", I_SHAPE],
          ["T", T_SHAPE],
          ["O", O_SHAPE],
          ["S", S_SHAPE],
          ["Z", Z_SHAPE],
          ["L", L_SHAPE],
          ["J", J_SHAPE],
        ];
        const pick = bag[Math.floor(Math.random() * bag.length)];
        active.id = pick[0];
        active.shape = clone4(pick[1]);
        active.c = 3; active.r = 0;
      }

      let fallTimer = 0, dtLast = 0;
      let score = 0;
      const FALL_INTERVAL = 0.5;

      function update(dt) {
        dtLast = dt;
        fallTimer += dt;

        const left  = pressed.has("ArrowLeft")  || pressed.has("a") || pressed.has("A");
        const right = pressed.has("ArrowRight") || pressed.has("d") || pressed.has("D");
        const rot   = pressed.has("ArrowUp")    || pressed.has("w") || pressed.has("W") || pressed.has(" ");
        const soft  = pressed.has("ArrowDown")  || pressed.has("s") || pressed.has("S");

        if (left)  tryMoveActive(-1, 0);
        if (right) tryMoveActive( 1, 0);
        if (rot)   tryRotateCW();
        if (soft)  tryMoveActive(0, 1);

        if (fallTimer >= FALL_INTERVAL) {
          fallTimer -= FALL_INTERVAL;
          if (!tryMoveActive(0, 1)) {
            lockActiveToBoard();
            const lines = clearLines();
            if (lines > 0) score += lines * 100;
            spawnRandom();
          }
        }
      }

      function drawGrid() {
        ctx.strokeStyle = "#222";
        for (let c = 0; c <= COLS; c++) { ctx.beginPath(); ctx.moveTo(c*CELL+0.5,0); ctx.lineTo(c*CELL+0.5,canvas.height); ctx.stroke(); }
        for (let r = 0; r <= ROWS; r++) { ctx.beginPath(); ctx.moveTo(0,r*CELL+0.5); ctx.lineTo(canvas.width,r*CELL+0.5); ctx.stroke(); }
      }

      function drawCell(c, r, color) {
        const x = c * CELL;
        const y = r * CELL;
        ctx.fillStyle = color;
        ctx.fillRect(x, y, CELL, CELL);
        const grad = ctx.createLinearGradient(x, y, x, y + CELL);
        grad.addColorStop(0, "rgba(255,255,255,0.28)");
        grad.addColorStop(0.45, "rgba(255,255,255,0.06)");
        grad.addColorStop(1, "rgba(0,0,0,0.10)");
        ctx.fillStyle = grad;
        ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);
        ctx.strokeStyle = "rgba(0,0,0,0.45)";
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 1, y + 1, CELL - 2, CELL - 2);
      }


      function drawBoard() {
        for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
          const cell = board[r][c];
          if (!cell) continue;
          drawCell(c, r, COLORS[cell] || "#555");
        }
      }

      function drawActive() {
        const color = COLORS[active.id] || "white";
        for (let r = 0; r < 4; r++) for (let c = 0; c < 4; c++) {
          if (!active.shape[r][c]) continue;
          drawCell(active.c + c, active.r + r, color);
        }
      }

      function drawHUD() {
        ctx.fillStyle = "lime";
        ctx.font = "14px monospace";
        ctx.fillText(`score: ${score}`, 10, 20);
        ctx.fillText(`dt: ${dtLast.toFixed(4)}`, 10, 38);
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid(); drawBoard(); drawActive(); drawHUD();
      }

      let last = performance.now();
      function loop(now) {
        const dt = (now - last) / 1000; last = now;
        update(dt); render();
        pressed.clear();
        requestAnimationFrame(loop);
      }
      spawnRandom();
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
